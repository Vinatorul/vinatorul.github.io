---
title:  "Квадратичные сортировки"
date:   2018-06-05
categories: [Руководства]
tags: [Сортировки]
---

Алгоритмы квадратичной сортировки, примеры реализаци и оценка временной сложности.
<!--more-->

## Сортировка выбором

Пожалуй самый очевидный способ сортировки массива --- сортировка выбором. Он интуитивно понятен и часто встречается в реальной жизни: находим минимальный элемент, "перекладывем" его в начало, продолжаем, пока массив не будет отсортирован.

Более точно идею сортировки объясняет следующий

### Пример

Пусть задан массив

$$
A = [6, 5, 3, 7, 8, 1, 9]
$$

Минимальный элемент в нём: 1, поменяем её с первым элментом массива местами, получаем 

$$
A = [1, 5, 3, 7, 8, 6, 9]
$$.

Теперь наёдём минимальный элемент в подмассиве $$[5, 3, 7, 8, 6, 9]$$, это будет число 3. Поменяем его со вторым элементом массива $$A$$ местами, получаем 

$$
A = [1, 3, 5, 7, 8, 6, 9]
$$.

Продолжая так далее получим 

$$
A = [1, 3, 5, 6, 7, 8, 9]
$$.

### Оценка сложности

Легко заметить, что для того, чтобы упорядочить весь массив нам потребуется ровно $$N-1$$ шаг, где $$N$$ --- длина массива. Также заметим, что поиск минимума в массиве есть линейный поиск, для которого также требуется $$N-1$$ шаг. Перемножая эти числа получаем, что для того, чтобы отсортировать *весь* массив потребуется $$(N-1)^2$$ шагов. Получается *квадратичная зависимость* времени работы алгоритма от объема входных данных. Поэтому такую сортировку называют **квадратичной**.

### Примеры реализации

Пример реализации на языке Python:

{% highlight python %}
A = [6, 5, 3, 7, 8, 1, 9]
for i in range(len(A)-1):
    m = i # Обратите внимание, что мы храним не сам минимум, а индекс минимума
    for j in range(i+1, len(A)):
        if A[j] < A[m]:
            m = j 
    A[i], A[m] = A[m], A[i]
print(A) # [1, 3, 5, 6, 7, 8, 9]
{% endhighlight %}

Пример реализации на языке C++:

{% highlight cpp %}
// Требуется 11 стандарт для такого способа задания вектора
vector<int> A = {6, 5, 3, 7, 8, 1, 9};
for (int i = 0; i < A.size()-1; ++i) {
    int m = i; // Обратите внимание, что мы храним не сам минимум, а индекс минимума
    for (int j = i+1; j < A.size(); ++j)
        if (A[j] < A[m])
            m = j; 
    swap(A[i], A[m]);
}
// Требуется 11 стандарт для такого способа обхода вектора
for (auto &i : A)
    cout << i << " "; // 1 3 5 6 7 8 9 
{% endhighlight %}

## Сортировка методом простого обмена aka "Пузырёк"


