---
title:  "Квадратичные сортировки"
date:   2018-06-06
categories: [Руководства]
tags: [Сортировки]
---

Алгоритмы квадратичной сортировки, примеры реализаци и оценка временной сложности.
<!--more-->

## Сортировка выбором

Пожалуй самый очевидный способ сортировки массива --- сортировка выбором. Он интуитивно понятен и часто встречается в реальной жизни: находим минимальный элемент, "перекладывем" его в начало, продолжаем, пока массив не будет отсортирован.

Более точно идею сортировки объясняет следующий

### Пример

Пусть задан массив

$$
A = [6, 5, 3, 7, 8, 1, 9]
$$

Минимальный элемент в нём: 1, поменяем её с первым элментом массива местами, получаем 

$$
A = [1, 5, 3, 7, 8, 6, 9]
$$

Теперь наёдём минимальный элемент в подмассиве $$[5, 3, 7, 8, 6, 9]$$, это будет число 3. Поменяем его со вторым элементом массива $$A$$ местами, получаем 

$$
A = [1, 3, 5, 7, 8, 6, 9]
$$

Продолжая так далее получим 

$$
A = [1, 3, 5, 6, 7, 8, 9]
$$

### Оценка сложности

Легко заметить, что для того, чтобы упорядочить весь массив нам потребуется ровно $$N-1$$ шаг, где $$N$$ --- длина массива. Также заметим, что поиск минимума в массиве есть линейный поиск, для которого также требуется $$N-1$$ шаг. Перемножая эти числа получаем, что для того, чтобы отсортировать *весь* массив потребуется $$(N-1)^2$$ шагов. Получается *квадратичная зависимость* времени работы алгоритма от объема входных данных. Поэтому такую сортировку называют **квадратичной**.

### Примеры реализации

Пример реализации на языке Python:

{% highlight python %}
A = [6, 5, 3, 7, 8, 1, 9]
for i in range(len(A)-1):
    m = i # Обратите внимание, что мы храним не сам минимум, а индекс минимума
    for j in range(i+1, len(A)):
        if A[j] < A[m]:
            m = j 
    A[i], A[m] = A[m], A[i]
print(A) # [1, 3, 5, 6, 7, 8, 9]
{% endhighlight %}

Пример реализации на языке C++:

{% highlight cpp %}
// Требуется 11 стандарт для такого способа задания вектора
vector<int> A = {6, 5, 3, 7, 8, 1, 9};
for (int i = 0; i < A.size()-1; ++i) {
    int m = i; // Обратите внимание, что мы храним не сам минимум, а индекс минимума
    for (int j = i+1; j < A.size(); ++j)
        if (A[j] < A[m])
            m = j; 
    swap(A[i], A[m]);
}
// Требуется 11 стандарт для такого способа обхода вектора
for (auto &i : A)
    cout << i << " "; // 1 3 5 6 7 8 9 
{% endhighlight %}

## Сортировка методом простого обмена aka "Пузырёк"

Заметим, что в отсортированном массиве все пары соседних элементов упорядочены. На этой идее основана сортировка методом простого обмена. Будем сравнивать пары соседних элеметов, если в какой-то момент упорядоченность будет нарушена --- просто поменяем элементы местами.

### Пример

Пусть задан массив

$$
A = [6, 5, 3, 7, 8, 1]
$$

Сравниваем 6 и 5, 6 больше 5, следовательно порядок нарушается --- меняем элементы местами

$$
A = [5, 6, 3, 7, 8, 1]
$$

Переходим к следующей паре 6 и 3. Порядок снова нарушен --- переставляем

$$
A = [5, 3, 6, 7, 8, 1]
$$

В следующей паре 6 и 7 элементы упорядочены, просто переходим дальше, не изменяя массив

$$
A = [5, 3, 6, 7, 8, 1]
$$

Пара 7 и 8 упорядочена --- идём дальше


$$
A = [5, 3, 6, 7, 8, 1]
$$

В паре 8 и 1 порядок снова нарушен --- меняем местами


$$
A = [5, 3, 6, 7, 1, 8]
$$

Легко заметить, что после прохода по массиву максимальный элемент занимает своё место. Поэтому эту сортировку также называют "метод пузырька" --- максимальные элементы "всплывают" к верху массива, как пузырьки в воде.

### Оценка сложности

Легко заметить, что для того, чтобы упорядочить весь массив нам потребуется ровно $$N-1$$ шаг. На первом шаге производится $$N-1$$ проверка, на втором шаге $$N-2$$ проверки, итд. Очевидно, что количество действий будет равно $$\frac{N\cdot N-1}{2}$$, т.е. снова получается *квадратичная зависимость* времени работы алгоритма от объема входных данных.

### Примеры реализации

Пример реализации на языке Python:

{% highlight python %}
A = [6, 5, 3, 7, 8, 1]
for i in range(len(A)-1):
    for j in range(len(A) - i - 1):
        if A[j] > A[j+1]:
            A[j], A[j+1] = A[j+1], A[j]
print(A) # [1, 3, 5, 6, 7, 8]
{% endhighlight %}


Пример реализации на языке C++:

{% highlight cpp %}
// Требуется 11 стандарт для такого способа задания вектора
vector<int> A = {6, 5, 3, 7, 8, 1};
for (int i = 0; i < A.size()-1; ++i) {
    for (int j = 0; j < A.size() - i - 1; ++j)
        if (A[j] > A[j+1])
            swap(A[j], A[j+1]);
}
// Требуется 11 стандарт для такого способа обхода вектора
for (auto &i : A)
    cout << i << " "; // 1 3 5 6 7 8
{% endhighlight %}
