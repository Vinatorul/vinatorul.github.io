---
title:  "Разбор задач муниципального этапа ВсОШ 2016/2017"
date:   2016-11-17
categories: [tutorials, vos]
tags: [vos]
author: Alexander Kuvaev
---

Ниже приводится разбор муниципального этапа Всероссийской олимпиады школьников по информатике 2016/2017 с примерами реализации.

Перед прочтением разбора рекомендуется ознакомиться с задачами и попробовать их решить на [неофициальном зеркале олимпиады](https://contest.yandex.ru/contest/3462).
<!-- more -->

# Клетчатые прямоугольники

![](/assets/mvos-2k16-1.png){: .centered}

Художник-супрематист решил закрасить клетчатый прямоугольник.
Вначале он закрасил клетки по периметру в один ряд.
Подсчитал количество закрашенных клеток, их оказалось $$4 \leq N \leq 100$$.
Какое максимальное количество клеток ему может потребоваться закрасить?

### Решение

Классическая задача нахождения максимальной площади по заданному периметру. Задачу можно решить просто перебором за $$O(n)$$, однако существует красивое решение за O(1), рассмотрим его ниже.

Достаточно было заметить, что количество закрашенных клеток в точности равно периметру искомого прямоугольника плюс четыре угловых клетки.
Разберём решение этой задачи, пусть $$a, b$$ - стороны искомого прямоугольника, тогда его периметр $$P = N-4$$ также будет равен $$2\cdot a + 2\cdot b$$, а площадь $$S = a\cdot b$$.

Выражаем $$b = \frac{P~-~2\cdot a}{2}$$, тогда $$S = \frac{P\cdot a}{2} - a^2$$.
Рассмотрим площадь, как функцию от одной переменной $$a$$, необходимо найти её наибольшее значение. 
Для этого заметим, что $$S(a)$$ - парабола с ветвями, направленными вниз, следовательно она принимает своё наибольшее значение в вершине $$\left(\frac{P}{4}, \frac{P^2}{16}\right)$$.

Покажем теперь, что $$S = \left[\frac{P^2}{16}\right]$$.

Пусть $$a = \left[\frac{P}{4}\right]$$, тогда $$b = \left[\frac{P~-~2\cdot\left[\frac{P}{4}\right]}{2}\right]$$ и $$S = \left[\frac{P}{4}\right]\cdot\left(\frac{P}{2} - \left[\frac{P}{4}\right]\right)$$.

Тогда $$S = \left[\frac{P}{4}\right]\cdot\left(\frac{P}{2} - \left[\frac{P}{4}\right]\right) \leq \frac{P}{4}\cdot\left(\frac{P}{2} - \frac{P}{4}\right) = \frac{P^2}{16}$$.

В то же время $$S = \left[\frac{P}{4}\right]\cdot\left(\frac{P}{2} - \left[\frac{P}{4}\right]\right) \geq \left(\frac{P}{4} - 1\right)\cdot\left(\frac{P}{2} - \frac{P}{4} + 1\right) = \left(\frac{P}{4} - 1\right)\cdot\left(\frac{P}{4} + 1\right) = \frac{P^2}{16} - 1$$.

Получаем $$\frac{P^2}{16} - 1 \leq S \leq \frac{P^2}{16}$$, что и требовалось доказать.

### Реализация

{% highlight cpp %}
int N;
cin >> N;
N -= 4;
cout << N*N/16;
{% endhighlight %}

# Диофантово уравнение

Петя очень любит решать уравнения. Однажды в одной математической книжке ему на глаза попалось уравнение $$x + y + xy = n$$. Петя захотел узнать, сколько пар неотрицательных целых чисел $$\left(x, y\right)$$, являются решениями этого уравнения.

### Решение

Прибавим к обеим частям уравнения единицу $$x + y + xy + 1 = n + 1$$, и сгруппируем слагаемые в левой части уравнения следующим образом: $$\left(x + 1\right) + \left(xy + y\right)$$. Тогда $$\left(x + 1\right)\cdot\left(y + 1\right) = n + 1$$. Таким образом, задача сводится к поиску количества делителей числа $$n + 1$$, у которой существует решение за $$O\left(\sqrt{n}\right)$$. 

### Реализация

{% highlight cpp %}
int n;
cin >> n;
int answer = 0;
int i = 1;
for (; i*i < n+1; ++i)
    if ((n+1)%i == 0)
        answer += 2;
if (i*i == n+1)
    answer++;
cout << answer;
{% endhighlight %}

# Системы счисления

Учитель предложил ученикам в равенстве $$X + Y = Z$$ определить, в какой системе счисления оно записано. Например, $$1 + 1 = 10$$ верно для двоичной системы, а равенство $$2В + 15А = 184$$ будет верным в системе счисления с основанием 17.

### Решение

Задачу следует решать перебором по основанию системы счисления, переводя в неё числа $$X$$, $$Y$$ и $$Z$$, и проверяя корректность равенства в этой системе. Сначала по цифрам числел $$X$$, $$Y$$, $$Z$$ определим минимальное основание, с которого будет начинаться перебор. Если в каком-то числе встречается цифра $$x$$, то основание не может быть меньше $$x + 1$$. Затем производится перебор от минимального основания до 36.

### Реализация

#### Определение порядкового номера цифры
{% highlight cpp %}
int get_number(const char c) {
    if ((c >= '0') && (c <= '9'))
        return c - '0';
    else
        return c - 'A' + 10;
}
{% endhighlight %}

#### Чтения чисел и поиск минимально возможного основания

{% highlight cpp %}
string s;
cin >> s;
int min_ss = 1;
int X[10], Y[10], Z[10];
int X_len(0), Y_len(0), Z_len(0);
int i = 0;
while (s[i] != '+') {
    X[X_len] =  get_number(s[i]);
    min_ss = max(min_ss, X[X_len]);
    i++;
    X_len++;
}
i++;
while (s[i] != '=') {
    Y[Y_len] =  get_number(s[i]);
    min_ss = max(min_ss, Y[Y_len]);
    i++;
    Y_len++;
}
i++;
while (i < s.length()) {
    Z[Z_len] =  get_number(s[i]);
    min_ss = max(min_ss, Z[Z_len]);
    i++;
    Z_len++;
}
min_ss++;
{% endhighlight %}

#### Перебор оснований

{% highlight cpp %}
long long X_num;
long long Y_num;
long long Z_num;
for (int i = min_ss; i <= 36; ++i) {
    X_num = 0;
    for (int j = 0; j < X_len; ++j)
        X_num = X_num*i + X[j];
    Y_num = 0;
    for (int j = 0; j < Y_len; ++j)
        Y_num = Y_num*i + Y[j];
    Z_num = 0;
    for (int j = 0; j < Z_len; ++j)
        Z_num = Z_num*i + Z[j];
    if (X_num + Y_num == Z_num) {
        cout << i;
        break;
    }
}
{% endhighlight %}

# Три кучи камней

Имеются три кучи камней (в первой $$А$$ камней, во второй – $$В$$, в третьей – $$С$$ камней). Два игрока по очереди делают ходы. На каждом ходу игрок выбирает две кучи и из меньшей в большую перекладывает любое число камней. Выигрывает тот, кто первым соберет все камни в одной куче. Определите, кто из игроков победит в игре при данном наборе $$\left(А, В, С\right)$$, если оба игрока играют наилучшим образом.

### Решение

Определим стратегию победы первого игрока. Первый игрок выигрывает только тогда, когда на его ходу осталось только две кучи. Поскольку оба игрока играют наилучим образом, то это могло произойти, только если на ходу второго игрока было две кучи из одного камня, т.е. ситуация $$\left(1, 1, A+B+C - 2\right)$$, и какие бы две кучи ни выбрал второй игрок - одна из них опустеет.

Пусть $$x \leq y \leq z$$ - количество камней в кучах. Заметим, что если $$x \neq y$$, и первый игрок будет всегда выравнивать две кучи с минимальными значениями $$x$$ и $$y$$, то после хода второго игрока $$x$$ никогда не будет равен $$y$$, в частности это значит, что второй игрок никогда не сможет привести первого к ситуации $$\left(1, 1, A+B+C - 2\right)$$. Поэтому выигрышная ситуация это $$x < y \leq z$$.

Поэтому для определения победителя достаточно проверить равенство $$x$$ и $$y$$, и если оно выполняется, то выигрывает второй игрок, в противном случае - первый.

### Реализация

{% highlight cpp %}
int x, y, z;
cin >> x >> y >> z;
if (y < x)
    swap(x, y);
if (z < x)
    swap(x, z);
if (z < y)
    swap(y, z);
if (x < y) 
    cout << 1;
else
    cout << 2;
{% endhighlight %}

# Фракталы

![](/assets/mvos-2k16-2.jpg){: .centered}

Кривая, изображенная на рисунке, называется кривой дракона Она представляет собой геометрическую фигуру, которая строится следующим образом: на первом шаге проводится отрезок из начала координатной плоскости в точку $$\left(0; 1\right)$$. Далее на каждом шаге из конца, построенной кривой, повторяется уже нарисованная часть фигуры, повернутая на 90 градусов против часовой стрелки (см. рисунок).

![](/assets/mvos-2k16-3.png){: .centered}

Один из членов жюри попробовал сам изобразить «кривую дракона», и теперь он хочет знать, в какой точке координатной плоскости он закончил ее рисовать, проделав описанные выше $$N$$ шагов. Требуется написать программу, которая по заданному числу $$N$$ определяет координаты конца кривой после выполнения $$N$$ шагов.

### Решение

Пусть $$\left(x, y\right)$$ - координаты конца кривой на $$n - 1$$ шаге. Концом кривой на шаге с номером $$n$$ будет точка, полученная из начала координат поворотом на 90 градусов против часовой стрелки вокруг точки $$\left(x, y\right)$$. С другой стороны это преобразование можно рассматривать как поворот кривой на 90 градусов вокруг начала координат, а затем параллельный перенос в точку $$\left(x, y\right)$$. При повороте точка $$\left(x, y\right)$$ переходит в $$\left(-y, x\right)$$, а при последующем переносе в точку $$\left(x+y, y-x\right)$$.

### Реализация

{% highlight cpp %}
int n;
cin >> n;
int x1(0), x2, y1(1), y2;
for (int i = 0; i < n-1; ++i) {
    x2 = x1+y1;
    y2 = y1-x1;
    swap(x1, x2);
    swap(y1, y2);
}
cout << x1 << ' ' << y1;
{% endhighlight %}